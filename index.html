<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Seoul Travel Map</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- Panzoom Library -->
    <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    
    <!-- Icons & Fonts -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&family=Fredoka:wght@500;600&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #111; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; overflow: hidden; }
        .font-cute { font-family: 'Fredoka', 'Noto Sans TC', sans-serif; }
        
        /* App 容器 */
        #app-container { 
            max-width: 480px; 
            height: 100dvh; 
            margin: 0 auto; 
            background-color: #fff; 
            position: relative; 
            overflow: hidden; 
            display: flex;
            flex-direction: column;
        }
        
        /* Pin Styles */
        .pin-marker { position: absolute; transform: translate(-50%, -100%); cursor: pointer; z-index: 10; display: flex; flex-direction: column; align-items: center; pointer-events: auto; user-select: none; -webkit-user-select: none; }
        .pin-icon-box { width: 44px; height: 44px; background: white; border-radius: 50%; border: 3px solid white; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.25); display: flex; align-items: center; justify-content: center; transition: transform 0.2s; }
        .pin-icon-box img { width: 100%; height: 100%; object-fit: cover; }
        .pin-tail { width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 8px solid white; margin-top: -2px; filter: drop-shadow(0 2px 1px rgba(0,0,0,0.1)); }
        .pin-label { background: rgba(255,255,255,0.95); padding: 3px 8px; border-radius: 8px; font-size: 10px; font-weight: 700; color: #4B5563; margin-top: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); white-space: nowrap; }
        
        /* Theme Colors */
        .pin-theme-pink .pin-icon-box { border-color: #FCE7F3; background: #FCE7F3; color: #EC4899; } .pin-theme-pink .pin-tail { border-top-color: #FCE7F3; }
        .pin-theme-blue .pin-icon-box { border-color: #DBEAFE; background: #DBEAFE; color: #3B82F6; } .pin-theme-blue .pin-tail { border-top-color: #DBEAFE; }
        .pin-theme-green .pin-icon-box { border-color: #D1FAE5; background: #D1FAE5; color: #10B981; } .pin-theme-green .pin-tail { border-top-color: #D1FAE5; }
        .pin-theme-yellow .pin-icon-box { border-color: #FEF3C7; background: #FEF3C7; color: #F59E0B; } .pin-theme-yellow .pin-tail { border-top-color: #FEF3C7; }
        .pin-theme-purple .pin-icon-box { border-color: #EDE9FE; background: #EDE9FE; color: #8B5CF6; } .pin-theme-purple .pin-tail { border-top-color: #EDE9FE; }

        @keyframes bounce-soft { 0%, 100% { transform: translate(-50%, -100%); } 50% { transform: translate(-50%, -108%); } }
        .animate-bounce-soft { animation: bounce-soft 2s infinite ease-in-out; }

        /* 拖曳中的 Pin 樣式 */
        .pin-dragging { z-index: 100 !important; transition: none !important; }
        .pin-dragging .pin-icon-box { transform: scale(1.2); box-shadow: 0 10px 20px rgba(0,0,0,0.3); }
        .pin-dragging.animate-bounce-soft { animation: none; } /* 拖曳時停止跳動 */

        /* 十字游標 (新增模式) */
        .cursor-crosshair-custom { cursor: crosshair; }
        
        .modal-enter-active, .modal-leave-active { transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .modal-enter-from, .modal-leave-to { opacity: 0; transform: scale(0.9); }
    </style>
</head>
<body>
<div id="app">
    <div id="app-container">
        
        <!-- UI Layer -->
        
        <!-- 新增按鈕 (左上角) -->
        <button class="fixed top-4 left-4 z-50 w-12 h-12 rounded-full shadow-lg flex items-center justify-center transform transition-all duration-300"
                :class="isAddingMode ? 'bg-gray-800 text-white rotate-45 scale-110' : 'bg-white/90 backdrop-blur text-pink-500 hover:scale-105 active:scale-95'"
                :style="{ maxWidth: '480px' }" 
                @click.stop="toggleAddMode">
            <i class="fas fa-plus text-xl"></i>
        </button>

        <!-- 已移除提示框 -->

        <!-- Map Layer -->
        <div class="relative w-full h-full bg-white overflow-hidden" id="scene-container">
            
            <div id="panzoom-area" class="w-full flex flex-col origin-top-left bg-white min-h-full">
                
                <!-- 
                    地圖內容容器
                    事件綁定：
                    1. @click: 處理「新增模式」下的單擊新增
                    2. @mousemove/touchmove/mouseup/touchend: 處理「長按後」的圖標拖曳
                -->
                <div id="map-content" 
                     class="relative w-full pb-20 select-none"
                     :class="{'cursor-crosshair-custom': isAddingMode}"
                     ref="mapContentRef"
                     @click="handleMapClick"
                     @mousemove="handleContainerMove"
                     @touchmove="handleContainerMove"
                     @mouseup="handleContainerEnd"
                     @touchend="handleContainerEnd"
                     @mouseleave="handleContainerEnd">
                    
                    <!-- map.png -->
                    <img src="map.png" class="w-full h-auto block pointer-events-none" alt="Seoul Map">
                    
                    <!-- 分隔線 -->
                    <div class="w-full h-2 bg-gray-100/50"></div>

                    <!-- subway.png -->
                    <img src="subway.png" class="w-full h-auto block pointer-events-none" alt="Korea Subway Map">

                    <!-- Existing Pins -->
                    <!-- 
                        Pin 事件綁定：
                        1. mousedown/touchstart: 開始偵測長按
                        2. click: 處理單擊(詳情)/雙擊(編輯)，需檢查是否剛拖曳完
                    -->
                    <div v-for="spot in spots" :key="spot.id"
                         class="pin-marker"
                         :class="[`pin-theme-${spot.theme}`, isDraggingSpotId === spot.id ? 'pin-dragging' : 'animate-bounce-soft']"
                         :style="{ top: spot.top, left: spot.left }"
                         @touchstart="handlePinStart(spot, $event)"
                         @mousedown="handlePinStart(spot, $event)"
                         @click.stop="handlePinClick(spot, $event)">
                        <div class="pin-icon-box">
                            <img v-if="spot.images && spot.images.length > 0" :src="spot.images[0]" class="w-full h-full object-cover">
                            <i v-else class="fas text-lg" :class="{
                                'fa-utensils': spot.category === 'food',
                                'fa-shopping-bag': spot.category === 'shopping',
                                'fa-camera': spot.category === 'spot'
                            }"></i>
                        </div>
                        <div class="pin-tail"></div>
                        <div class="pin-label">{{ spot.name }}</div>
                    </div>

                </div>

            </div>

        </div>

        <!-- 通用彈窗 (新增/編輯) -->
        <transition name="modal">
            <div v-if="showModal" class="fixed inset-0 z-[60] flex items-center justify-center bg-black/60 backdrop-blur-sm p-5" @click.self="cancelModal">
                <div class="bg-white w-full max-w-xs rounded-3xl p-6 shadow-2xl transform transition-all">
                    
                    <h3 class="text-lg font-bold text-gray-800 mb-4 text-center">
                        {{ isEditing ? '編輯地標' : '新增地標' }}
                    </h3>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="text-xs font-bold text-gray-400 uppercase ml-1 block mb-2">類別</label>
                            <div class="flex gap-2">
                                <button @click="quickForm.category = 'spot'" class="flex-1 py-2 rounded-xl text-xs font-bold border transition-colors flex flex-col items-center justify-center gap-1" :class="quickForm.category === 'spot' ? 'bg-pink-50 border-pink-200 text-pink-500' : 'border-gray-200 text-gray-400'"><i class="fas fa-camera text-sm"></i> 景點</button>
                                <button @click="quickForm.category = 'food'" class="flex-1 py-2 rounded-xl text-xs font-bold border transition-colors flex flex-col items-center justify-center gap-1" :class="quickForm.category === 'food' ? 'bg-orange-50 border-orange-200 text-orange-500' : 'border-gray-200 text-gray-400'"><i class="fas fa-utensils text-sm"></i> 餐廳</button>
                                <button @click="quickForm.category = 'shopping'" class="flex-1 py-2 rounded-xl text-xs font-bold border transition-colors flex flex-col items-center justify-center gap-1" :class="quickForm.category === 'shopping' ? 'bg-blue-50 border-blue-200 text-blue-500' : 'border-gray-200 text-gray-400'"><i class="fas fa-shopping-bag text-sm"></i> 購物</button>
                            </div>
                        </div>
                        <div><label class="text-xs font-bold text-gray-400 uppercase ml-1">名稱</label><input v-model="quickForm.name" type="text" placeholder="地點名稱" class="mt-1 w-full bg-gray-100 rounded-xl px-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-pink-400"></div>
                        <div>
                            <label class="text-xs font-bold text-gray-400 uppercase ml-1 block mb-2">顏色</label>
                            <div class="flex justify-between gap-2">
                                <button v-for="color in ['pink', 'blue', 'green', 'yellow', 'purple']" :key="color" @click="quickForm.theme = color" class="w-8 h-8 rounded-full border-2 transition-transform active:scale-90" :class="[quickForm.theme === color ? 'border-gray-400 scale-110 shadow-sm' : 'border-transparent']" :style="{ backgroundColor: getColorCode(color) }"></button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex gap-3 mt-6">
                        <button v-if="isEditing" @click="deleteSpot" class="w-12 py-3 rounded-xl font-bold text-white bg-red-500 shadow-lg shadow-red-200 text-sm flex items-center justify-center">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                        
                        <button @click="cancelModal" class="flex-1 py-3 rounded-xl font-bold text-gray-500 bg-gray-100 text-sm">取消</button>
                        <button @click="confirmAction" class="flex-1 py-3 rounded-xl font-bold text-white bg-pink-500 shadow-lg shadow-pink-200 text-sm" :disabled="!quickForm.name">
                            {{ isEditing ? '儲存' : '建立' }}
                        </button>
                    </div>
                </div>
            </div>
        </transition>

    </div>
</div>

<script>
    const { createApp, ref, reactive, onMounted } = Vue;
    createApp({
        setup() {
            const spots = ref([]);
            const isAddingMode = ref(false);
            const showModal = ref(false);
            const isEditing = ref(false);
            const editingSpotId = ref(null);
            
            const tempCoords = ref(null); // 用於儲存點擊位置
            const mapContentRef = ref(null);
            
            const quickForm = reactive({ name: '', theme: 'pink', category: 'spot' });

            // Panzoom 實例
            let panzoomInstance = null;
            
            // 拖曳 & 長按邏輯變數
            const isDraggingSpotId = ref(null); // 當前正在拖曳的 Spot ID
            let longPressTimer = null;
            let startX = 0, startY = 0;
            let hasDragged = false; // 標記是否發生過拖曳 (用於防止拖曳結束觸發點擊)
            
            const LONG_PRESS_DURATION = 200; // 0.2秒
            const MOVE_THRESHOLD = 5; // 手指抖動容錯值

            // 雙擊偵測
            let clickCount = 0;
            let clickTimer = null;

            // 初始化 Panzoom
            const initPanzoom = () => {
                const elem = document.getElementById('panzoom-area');
                if (!elem) return;
                if (panzoomInstance) panzoomInstance.destroy();

                panzoomInstance = Panzoom(elem, {
                    maxScale: 4, minScale: 1, startScale: 1, contain: 'outside', cursor: 'default', touchAction: 'none' 
                });

                if (elem.parentElement) {
                    elem.parentElement.addEventListener('wheel', panzoomInstance.zoomWithWheel);
                }
            };

            onMounted(() => {
                const savedData = localStorage.getItem('seoul_travel_app_data');
                if (savedData) spots.value = JSON.parse(savedData);
                if (document.readyState === 'complete') initPanzoom();
                else window.addEventListener('load', initPanzoom);
                window.addEventListener('resize', () => setTimeout(initPanzoom, 100));
            });

            // 工具函數：取得事件座標
            const getEventCoords = (e) => {
                if (e.touches && e.touches.length > 0) {
                    return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
                }
                return { clientX: e.clientX, clientY: e.clientY };
            };

            // 工具函數：計算相對百分比座標
            const calculateRelativeCoords = (clientX, clientY) => {
                const rect = mapContentRef.value.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                return {
                    left: (x / rect.width * 100).toFixed(2) + '%',
                    top: (y / rect.height * 100).toFixed(2) + '%',
                };
            };

            // --- 1. 新增功能：單擊地圖 ---
            const toggleAddMode = () => {
                isAddingMode.value = !isAddingMode.value;
                showModal.value = false;
            };

            const handleMapClick = (e) => {
                // 只有在新增模式下，且沒有正在拖曳圖標時，才觸發新增
                if (!isAddingMode.value) return;
                if (hasDragged) return; 

                const { clientX, clientY } = getEventCoords(e);
                tempCoords.value = calculateRelativeCoords(clientX, clientY);

                // 開啟新增視窗
                isEditing.value = false;
                editingSpotId.value = null;
                quickForm.name = '';
                quickForm.theme = 'pink';
                quickForm.category = 'spot';
                showModal.value = true;
            };

            // --- 2. 移動功能：長按圖標拖曳 ---
            
            // 按下圖標：開始偵測長按
            const handlePinStart = (spot, e) => {
                // 不阻止冒泡 (讓 Panzoom 也能收到)，但如果長按觸發了，我們再攔截
                const { clientX, clientY } = getEventCoords(e);
                startX = clientX;
                startY = clientY;
                hasDragged = false;
                
                // 設定長按計時器
                longPressTimer = setTimeout(() => {
                    // 長按時間到！開始拖曳模式
                    isDraggingSpotId.value = spot.id;
                    hasDragged = true; // 標記為拖曳行為
                    
                    // 震動回饋
                    if (navigator.vibrate) navigator.vibrate(50);
                    
                    // 暫停 Panzoom，避免地圖跟著動
                    if (panzoomInstance) panzoomInstance.setOptions({ disablePan: true });
                    
                }, LONG_PRESS_DURATION);
            };

            // 移動 (在容器上監聽，保證拖曳流暢)
            const handleContainerMove = (e) => {
                const { clientX, clientY } = getEventCoords(e);

                if (isDraggingSpotId.value) {
                    // 正在拖曳圖標
                    e.preventDefault(); // 防止滾動
                    e.stopPropagation();
                    
                    // 更新該圖標的位置
                    const spot = spots.value.find(s => s.id === isDraggingSpotId.value);
                    if (spot) {
                        const coords = calculateRelativeCoords(clientX, clientY);
                        spot.top = coords.top;
                        spot.left = coords.left;
                    }
                } else {
                    // 還沒觸發長按，檢查是否移動超過閾值 (若是，則取消長按偵測，視為滑動地圖)
                    if (longPressTimer) {
                        const moveX = Math.abs(clientX - startX);
                        const moveY = Math.abs(clientY - startY);
                        if (moveX > MOVE_THRESHOLD || moveY > MOVE_THRESHOLD) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    }
                }
            };

            // 放開
            const handleContainerEnd = () => {
                // 清除長按計時器
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }

                if (isDraggingSpotId.value) {
                    // 拖曳結束
                    isDraggingSpotId.value = null;
                    
                    // 恢復 Panzoom
                    if (panzoomInstance) panzoomInstance.setOptions({ disablePan: false });
                    
                    // 儲存新位置
                    localStorage.setItem('seoul_travel_app_data', JSON.stringify(spots.value));
                    
                    // 注意：這裡不設定 hasDragged = false，保留它為 true
                    // 這樣 click 事件處理器就知道「剛才發生了拖曳」，而不是點擊
                    // 我們利用 setTimeout 在下一個 tick 清除它，或者讓 click handler 自己判斷
                    setTimeout(() => { hasDragged = false; }, 100);
                }
            };

            // --- 3. 點擊圖標：詳情與編輯 ---
            const handlePinClick = (spot, e) => {
                // 如果剛剛發生了拖曳，則忽略這次「點擊」(因為這是拖曳結束時的 mouseup 觸發的)
                if (hasDragged) {
                    hasDragged = false;
                    return;
                }

                if (isAddingMode.value) return; // 新增模式下不處理點擊詳情

                clickCount++;
                if (clickCount === 1) {
                    clickTimer = setTimeout(() => {
                        clickCount = 0;
                        window.location.href = `detail.html?id=${spot.id}`;
                    }, 250); 
                } else {
                    clearTimeout(clickTimer);
                    clickCount = 0;
                    openEditModal(spot);
                }
            };

            // --- 編輯 / 刪除 / 儲存 ---
            const openEditModal = (spot) => {
                isEditing.value = true;
                editingSpotId.value = spot.id;
                quickForm.name = spot.name;
                quickForm.theme = spot.theme;
                quickForm.category = spot.category;
                showModal.value = true;
            };

            const deleteSpot = () => {
                if (!editingSpotId.value) return;
                if (confirm('確定要刪除這個地標嗎？')) {
                    spots.value = spots.value.filter(s => s.id !== editingSpotId.value);
                    localStorage.setItem('seoul_travel_app_data', JSON.stringify(spots.value));
                    showModal.value = false;
                }
            };

            const confirmAction = () => {
                if (isEditing.value) {
                    const spot = spots.value.find(s => s.id === editingSpotId.value);
                    if (spot) {
                        spot.name = quickForm.name;
                        spot.theme = quickForm.theme;
                        spot.category = quickForm.category;
                    }
                } else {
                    if (!tempCoords.value) return;
                    const newSpot = {
                        id: Date.now(),
                        name: quickForm.name,
                        theme: quickForm.theme,
                        category: quickForm.category,
                        top: tempCoords.value.top,
                        left: tempCoords.value.left,
                        date: new Date().toLocaleDateString(),
                        images: [],
                        description: '', hours: '', url: '', mapUrl: ''
                    };
                    spots.value.push(newSpot);
                }
                
                localStorage.setItem('seoul_travel_app_data', JSON.stringify(spots.value));
                showModal.value = false;
                isAddingMode.value = false;
                tempCoords.value = null;
            };

            const cancelModal = () => { 
                showModal.value = false; 
                tempCoords.value = null; 
            };
            
            const getColorCode = (n) => ({ pink: '#EC4899', blue: '#3B82F6', green: '#10B981', yellow: '#F59E0B', purple: '#8B5CF6' }[n]);

            return { 
                spots, isAddingMode, showModal, isEditing, quickForm, mapContentRef, isDraggingSpotId,
                toggleAddMode, handleMapClick, handlePinStart, handleContainerMove, handleContainerEnd, handlePinClick,
                confirmAction, cancelModal, deleteSpot, getColorCode 
            };
        }
    }).mount('#app');
</script>
</body>
</html>


