<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Seoul Travel Map</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <!-- Panzoom Library -->
    <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    
    <!-- Icons & Fonts -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;700&family=Fredoka:wght@500;600&display=swap" rel="stylesheet">
    
    <style>
        /* Global Reset & No Scroll */
        body { 
            font-family: 'Noto Sans TC', sans-serif; 
            background-color: #111; 
            margin: 0; 
            padding: 0; 
            -webkit-tap-highlight-color: transparent; 
            overflow: hidden; /* Disable body scroll */
            width: 100vw;
            height: 100vh;
        }
        
        /* App Container - Single Screen Flex Layout */
        #app-container { 
            max-width: 480px; 
            height: 100dvh; /* Use dynamic viewport height */
            margin: 0 auto; 
            background-color: #fff; 
            position: relative; 
            overflow: hidden; /* Disable internal scroll */
            display: flex;
            flex-direction: column;
        }
        
        /* Pin Styles */
        .pin-marker { position: absolute; transform: translate(-50%, -100%); cursor: pointer; z-index: 10; display: flex; flex-direction: column; align-items: center; pointer-events: auto; user-select: none; -webkit-user-select: none; }
        .pin-icon-box { width: 36px; height: 36px; background: white; border-radius: 50%; border: 2px solid white; overflow: hidden; box-shadow: 0 4px 10px rgba(0,0,0,0.25); display: flex; align-items: center; justify-content: center; transition: transform 0.2s; }
        .pin-icon-box img { width: 100%; height: 100%; object-fit: cover; }
        .pin-tail { width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 6px solid white; margin-top: -1px; filter: drop-shadow(0 2px 1px rgba(0,0,0,0.1)); }
        .pin-label { background: rgba(255,255,255,0.95); padding: 2px 6px; border-radius: 6px; font-size: 9px; font-weight: 700; color: #4B5563; margin-top: 2px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); white-space: nowrap; }
        
        /* Theme Colors */
        .pin-theme-pink .pin-icon-box { border-color: #FCE7F3; background: #FCE7F3; color: #EC4899; } .pin-theme-pink .pin-tail { border-top-color: #FCE7F3; }
        .pin-theme-blue .pin-icon-box { border-color: #DBEAFE; background: #DBEAFE; color: #3B82F6; } .pin-theme-blue .pin-tail { border-top-color: #DBEAFE; }
        .pin-theme-green .pin-icon-box { border-color: #D1FAE5; background: #D1FAE5; color: #10B981; } .pin-theme-green .pin-tail { border-top-color: #D1FAE5; }
        .pin-theme-yellow .pin-icon-box { border-color: #FEF3C7; background: #FEF3C7; color: #F59E0B; } .pin-theme-yellow .pin-tail { border-top-color: #FEF3C7; }
        .pin-theme-purple .pin-icon-box { border-color: #EDE9FE; background: #EDE9FE; color: #8B5CF6; } .pin-theme-purple .pin-tail { border-top-color: #EDE9FE; }

        @keyframes bounce-soft { 0%, 100% { transform: translate(-50%, -100%); } 50% { transform: translate(-50%, -108%); } }
        .animate-bounce-soft { animation: bounce-soft 2s infinite ease-in-out; }
        
        .pin-dragging { z-index: 100 !important; transition: none !important; }
        .pin-dragging .pin-icon-box { transform: scale(1.2); box-shadow: 0 10px 20px rgba(0,0,0,0.3); }
        .pin-dragging.animate-bounce-soft { animation: none; }

        .cursor-crosshair-custom { cursor: crosshair; }
        
        /* Transitions */
        .modal-enter-active, .modal-leave-active { transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .modal-enter-from, .modal-leave-to { opacity: 0; transform: scale(0.95); }
        .slide-up-enter-active, .slide-up-leave-active { transition: transform 0.3s ease-out, opacity 0.3s ease; }
        .slide-up-enter-from, .slide-up-leave-to { transform: translateY(100%); opacity: 0; }
        .fade-enter-active, .fade-leave-active { transition: opacity 0.2s ease; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        img { 
            -webkit-font-smoothing: antialiased; 
            image-rendering: high-quality; /* 嘗試使用瀏覽器高品質渲染 */
        }

        /* Zoom Container */
        #subway-panzoom-container { 
            will-change: transform; 
            cursor: grab; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            width: 100%; 
            height: 100%; 
        }
        
        /* 優化圖片樣式：
           1. 移除 max-width 限制，讓 Panzoom 決定大小
           2. 使用 will-change 提升性能
        */
        #subway-panzoom-container img { 
            width: auto;
            height: auto;
            max-width: none; /* 關鍵：允許圖片超過容器大小，保持原始解析度 */
            max-height: 100%; /* 初始載入時適應高度 */
            object-fit: contain; 
            pointer-events: none; 
            will-change: transform;
        }
        #subway-panzoom-container:active { cursor: grabbing; }
    </style>
</head>
<body>
<div id="app">
    <div id="app-container">
        
        <!-- Add Button -->
        <button class="absolute top-4 left-4 z-50 w-10 h-10 rounded-full shadow-lg flex items-center justify-center transform transition-all duration-300"
                :class="isAddingMode ? 'bg-gray-800 text-white rotate-45 scale-110' : 'bg-white/90 backdrop-blur text-pink-500 hover:scale-105 active:scale-95'"
                @click.stop="toggleAddMode">
            <i class="fas fa-plus text-sm"></i>
        </button>

        <!-- SECTION 1: Map Area (Flexible Height, No Scroll, Centered) -->
        <div class="flex-1 bg-gray-50 relative overflow-hidden flex items-center justify-center w-full select-none"
             :class="{'cursor-crosshair-custom': isAddingMode}">
            
            <div class="relative inline-block" 
                 ref="mapContentRef"
                 @click="handleMapClick"
                 @mousemove="handleContainerMove"
                 @touchmove="handleContainerMove"
                 @mouseup="handleContainerEnd"
                 @touchend="handleContainerEnd"
                 @mouseleave="handleContainerEnd">
                
                <img src="map.png" 
                     class="max-w-full max-h-[55vh] w-auto h-auto block pointer-events-none shadow-sm" 
                     alt="Seoul Map" 
                     onerror="this.src='https://placehold.co/600x800/png?text=Seoul+Map'">
                
                <div v-for="spot in spots" :key="spot.id"
                     class="pin-marker"
                     :class="[`pin-theme-${spot.theme}`, isDraggingSpotId === spot.id ? 'pin-dragging' : 'animate-bounce-soft']"
                     :style="{ top: spot.top, left: spot.left }"
                     @touchstart.stop="handlePinStart(spot, $event)"
                     @mousedown.stop="handlePinStart(spot, $event)"
                     @click.stop="handlePinClick(spot, $event)">
                    <div class="pin-icon-box">
                        <img v-if="spot.images && spot.images.length > 0" :src="spot.images[0]">
                        <i v-else class="fas text-sm" :class="{
                            'fa-utensils': spot.category === 'food',
                            'fa-shopping-bag': spot.category === 'shopping',
                            'fa-camera': spot.category === 'spot'
                        }"></i>
                    </div>
                    <div class="pin-tail"></div>
                    <div class="pin-label">{{ spot.name }}</div>
                </div>
            </div>
        </div>

        <!-- SECTION 2: Subway Area (Fixed Height, Zoomable, PNG Only) -->
        <div class="h-[40vh] w-full bg-gray-100 overflow-hidden relative border-t border-gray-200 z-10">
            <!-- Panzoom Container -->
            <div id="subway-panzoom-container">
                <!-- 
                     關鍵修改：
                     1. 使用 Wikimedia 的高解析度 PNG (2560px 寬) 替代本地小圖
                     2. 本地開發時，請確保您的 image.png 寬度至少有 2000px
                -->
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Seoul_Subway_Map_en.svg/2560px-Seoul_Subway_Map_en.svg.png" 
                     alt="Subway Map" 
                     @error="handleImgError"
                     ref="subwayImgRef">
            </div>
        </div>

        <!-- Modals (Overlay) - Same as before -->
        <!-- 1. Quick Add -->
        <transition name="modal">
            <div v-if="showQuickAddModal" class="fixed inset-0 z-[60] flex items-center justify-center bg-black/60 backdrop-blur-sm p-5" @click.self="cancelQuickAdd">
                <div class="bg-white w-full max-w-xs rounded-3xl p-6 shadow-2xl">
                    <h3 class="text-lg font-bold text-gray-800 mb-4 text-center">新增地標</h3>
                    <div class="space-y-4">
                        <div>
                            <label class="text-xs font-bold text-gray-400 uppercase ml-1 block mb-2">類別</label>
                            <div class="flex gap-2">
                                <button v-for="cat in ['spot', 'food', 'shopping']" :key="cat" @click="quickForm.category = cat" 
                                        class="flex-1 py-2 rounded-xl text-xs font-bold border transition-colors flex flex-col items-center justify-center gap-1" 
                                        :class="quickForm.category === cat ? getCategoryColorClass(cat) : 'border-gray-200 text-gray-400'">
                                    <i class="fas text-sm" :class="getCategoryIcon(cat)"></i>{{ getCategoryName(cat) }}
                                </button>
                            </div>
                        </div>
                        <div>
                            <label class="text-xs font-bold text-gray-400 uppercase ml-1">名稱</label>
                            <input v-model="quickForm.name" type="text" placeholder="地點名稱..." class="mt-1 w-full bg-gray-100 rounded-xl px-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-pink-400">
                        </div>
                        <div>
                            <label class="text-xs font-bold text-gray-400 uppercase ml-1 block mb-2">顏色</label>
                            <div class="flex justify-between gap-2">
                                <button v-for="color in ['pink', 'blue', 'green', 'yellow', 'purple']" :key="color" @click="quickForm.theme = color" 
                                        class="w-8 h-8 rounded-full border-2 transition-transform active:scale-90" 
                                        :class="[quickForm.theme === color ? 'border-gray-400 scale-110 shadow-sm' : 'border-transparent']" 
                                        :style="{ backgroundColor: getColorCode(color) }"></button>
                            </div>
                        </div>
                    </div>
                    <div class="flex gap-3 mt-6">
                        <button @click="cancelQuickAdd" class="flex-1 py-3 rounded-xl font-bold text-gray-500 bg-gray-100 text-sm">取消</button>
                        <button @click="confirmQuickAdd" class="flex-1 py-3 rounded-xl font-bold text-white bg-pink-50 shadow-lg shadow-pink-200 text-sm" :disabled="!quickForm.name">建立</button>
                    </div>
                </div>
            </div>
        </transition>

        <!-- 2. Detail Modal -->
        <transition name="slide-up">
            <div v-if="showDetailModal && selectedSpot" class="fixed inset-0 z-[70] flex flex-col justify-end items-center bg-black/50 backdrop-blur-[2px]" @click.self="closeDetailModal">
                <div class="bg-white w-full max-w-[480px] h-[85vh] rounded-t-3xl shadow-2xl flex flex-col overflow-hidden" @touchstart="handleSwipeStart" @touchend="handleSwipeEnd">
                    <div class="relative h-48 bg-gray-200 shrink-0 group">
                        <img v-if="detailForm.images && detailForm.images.length > 0" :src="detailForm.images[0]" class="w-full h-full object-cover">
                        <div v-else class="w-full h-full flex flex-col items-center justify-center text-gray-300 bg-gray-100"><i class="fas fa-image text-4xl mb-2 opacity-50"></i><span class="text-xs font-bold">尚無圖片</span></div>
                        <button @click="closeDetailModal" class="absolute top-4 right-4 w-8 h-8 rounded-full bg-black/30 backdrop-blur text-white flex items-center justify-center"><i class="fas fa-times"></i></button>
                    </div>
                    <div class="flex-1 overflow-y-auto p-6 no-scrollbar relative">
                        <div v-if="!isEditingDetail" class="space-y-4">
                            <h2 class="text-2xl font-bold text-gray-800">{{ detailForm.name }}</h2>
                            <p class="text-gray-600 text-sm">{{ detailForm.description || '暫無描述...' }}</p>
                        </div>
                        <div v-else class="space-y-4">
                            <input v-model="detailForm.name" class="w-full bg-gray-50 border rounded-lg px-3 py-2 text-sm">
                            <textarea v-model="detailForm.description" rows="3" class="w-full bg-gray-50 border rounded-lg px-3 py-2 text-sm"></textarea>
                            <div class="flex gap-2">
                                <button @click="$refs.fileInput.click()" class="flex-1 py-2 bg-pink-50 text-pink-500 rounded-lg text-sm font-bold"><i class="fas fa-camera mr-1"></i>上傳照片</button>
                                <input type="file" ref="fileInput" accept="image/*" class="hidden" @change="handleFileUpload">
                            </div>
                        </div>
                    </div>
                    <div class="p-4 border-t border-gray-100 bg-white flex gap-3 shrink-0">
                        <template v-if="!isEditingDetail">
                            <button @click="startEditing" class="flex-1 py-3 bg-gray-100 rounded-xl font-bold text-gray-700 text-sm"><i class="fas fa-pen mr-2"></i>編輯</button>
                        </template>
                        <template v-else>
                            <button @click="deleteSpot" class="w-12 py-3 bg-red-50 text-red-500 rounded-xl"><i class="fas fa-trash-alt"></i></button>
                            <button @click="saveDetailChanges" class="flex-1 py-3 bg-black text-white rounded-xl font-bold text-sm">儲存</button>
                        </template>
                    </div>
                </div>
            </div>
        </transition>

    </div>
</div>

<script>
    const { createApp, ref, reactive, onMounted, nextTick } = Vue;
    createApp({
        setup() {
            const spots = ref([]);
            const isAddingMode = ref(false); 
            const isProcessingImage = ref(false);
            const showQuickAddModal = ref(false);
            const showDetailModal = ref(false);
            const isEditingDetail = ref(false);
            const selectedSpot = ref(null);
            const currentSpotIndex = ref(-1);
            const fileInput = ref(null);
            const quickForm = reactive({ name: '', theme: 'pink', category: 'spot' });
            const detailForm = reactive({ id: null, name: '', theme: 'pink', category: 'spot', description: '', hours: '', url: '', mapUrl: '', images: [] });
            const tempImageUrl = ref('');
            const mapContentRef = ref(null);
            const tempCoords = ref(null);
            const isDraggingSpotId = ref(null);
            let longPressTimer = null;
            let startX = 0, startY = 0;
            let hasDragged = false;
            const LONG_PRESS_DURATION = 200; 
            const touchStartX = ref(0);
            const touchEndX = ref(0);
            
            // Panzoom State
            let subwayPanzoom = null;
            const subwayImgRef = ref(null);
            
            const handleImgError = (e) => {
                // 如果高解析度圖片載入失敗，退回到 Wikimedia 的另一種格式或普通連結
                e.target.src = 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Seoul_Subway_Map_en.svg/2000px-Seoul_Subway_Map_en.svg.png';
            };

            const initSubwayPanzoom = () => {
                const elem = document.getElementById('subway-panzoom-container');
                if (!elem) return;
                
                // If panzoom exists, destroy it first to avoid conflicts
                if (subwayPanzoom) subwayPanzoom.destroy();
                
                subwayPanzoom = Panzoom(elem, {
                    maxScale: 5, // 限制最大縮放倍率，避免過度放大變模糊
                    minScale: 1, 
                    startScale: 1, 
                    contain: 'outside', 
                    cursor: 'default', 
                    touchAction: 'none' // Critical for gesture support
                });
                elem.addEventListener('wheel', subwayPanzoom.zoomWithWheel);
            };

            onMounted(() => {
                const savedData = localStorage.getItem('seoul_travel_app_data');
                if (savedData) spots.value = JSON.parse(savedData);
                
                // Init panzoom for the PNG
                // Use nextTick to ensure image DOM is ready
                nextTick(() => {
                    initSubwayPanzoom();
                });
            });

            // Coords logic
            const getEventCoords = (e) => {
                if (e.touches && e.touches.length > 0) return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
                return { clientX: e.clientX, clientY: e.clientY };
            };

            const calculateRelativeCoords = (clientX, clientY) => {
                const rect = mapContentRef.value.getBoundingClientRect();
                return {
                    left: ((clientX - rect.left) / rect.width * 100).toFixed(2) + '%',
                    top: ((clientY - rect.top) / rect.height * 100).toFixed(2) + '%',
                };
            };

            const saveToLocal = () => {
                try { localStorage.setItem('seoul_travel_app_data', JSON.stringify(spots.value)); } catch (e) {}
            };

            const compressImage = (file) => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const maxWidth = 800; 
                            let width = img.width; let height = img.height;
                            if (width > maxWidth) { height = Math.round((height * maxWidth) / width); width = maxWidth; }
                            canvas.width = width; canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            resolve(canvas.toDataURL('image/jpeg', 0.7));
                        };
                    };
                });
            };

            const toggleAddMode = () => { isAddingMode.value = !isAddingMode.value; showQuickAddModal.value = false; showDetailModal.value = false; };
            const handleMapClick = (e) => {
                if (!isAddingMode.value || hasDragged) return;
                const { clientX, clientY } = getEventCoords(e);
                tempCoords.value = calculateRelativeCoords(clientX, clientY);
                quickForm.name = ''; quickForm.theme = 'pink'; quickForm.category = 'spot';
                showQuickAddModal.value = true;
            };

            const handlePinStart = (spot, e) => {
                const { clientX, clientY } = getEventCoords(e);
                startX = clientX; startY = clientY; hasDragged = false;
                longPressTimer = setTimeout(() => {
                    isDraggingSpotId.value = spot.id; hasDragged = true;
                    if (navigator.vibrate) navigator.vibrate(50);
                }, LONG_PRESS_DURATION);
            };

            const handleContainerMove = (e) => {
                const { clientX, clientY } = getEventCoords(e);
                if (isDraggingSpotId.value) {
                    e.preventDefault(); e.stopPropagation();
                    const spot = spots.value.find(s => s.id === isDraggingSpotId.value);
                    if (spot) {
                        const coords = calculateRelativeCoords(clientX, clientY);
                        spot.top = coords.top; spot.left = coords.left;
                    }
                } else if (longPressTimer) {
                    if (Math.abs(clientX - startX) > 5 || Math.abs(clientY - startY) > 5) {
                        clearTimeout(longPressTimer); longPressTimer = null;
                    }
                }
            };

            const handleContainerEnd = () => {
                if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
                if (isDraggingSpotId.value) {
                    isDraggingSpotId.value = null; saveToLocal();
                    setTimeout(() => { hasDragged = false; }, 100);
                }
            };

            const loadSpotData = (index) => {
                if (index < 0 || index >= spots.value.length) return;
                const spot = spots.value[index];
                selectedSpot.value = spot; currentSpotIndex.value = index;
                Object.assign(detailForm, JSON.parse(JSON.stringify(spot)));
                if (!detailForm.images) detailForm.images = [];
            }
            const handlePinClick = (spot, e) => {
                if (hasDragged || isAddingMode.value) return;
                const idx = spots.value.findIndex(s => s.id === spot.id);
                loadSpotData(idx);
                isEditingDetail.value = false; showDetailModal.value = true;
            };

            const handleSwipeStart = (e) => { touchStartX.value = e.changedTouches[0].screenX; };
            const handleSwipeEnd = (e) => {
                touchEndX.value = e.changedTouches[0].screenX;
                if (!isEditingDetail.value && Math.abs(touchEndX.value - touchStartX.value) > 50) {
                    if (touchEndX.value < touchStartX.value && currentSpotIndex.value < spots.value.length - 1) loadSpotData(currentSpotIndex.value + 1);
                    else if (touchEndX.value > touchStartX.value && currentSpotIndex.value > 0) loadSpotData(currentSpotIndex.value - 1);
                }
            };

            const cancelQuickAdd = () => { showQuickAddModal.value = false; tempCoords.value = null; };
            const confirmQuickAdd = () => {
                if (!tempCoords.value) return;
                spots.value.push({ id: Date.now(), name: quickForm.name, theme: quickForm.theme, category: quickForm.category, top: tempCoords.value.top, left: tempCoords.value.left, date: new Date().toLocaleDateString(), images: [], description: '', hours: '', url: '', mapUrl: '' });
                saveToLocal(); showQuickAddModal.value = false; isAddingMode.value = false; tempCoords.value = null;
            };
            const closeDetailModal = () => { showDetailModal.value = false; selectedSpot.value = null; currentSpotIndex.value = -1; };
            const startEditing = () => { isEditingDetail.value = true; tempImageUrl.value = ''; };
            const cancelEditing = () => { if (selectedSpot.value) loadSpotData(currentSpotIndex.value); isEditingDetail.value = false; };
            const saveDetailChanges = () => {
                const target = spots.value.find(s => s.id === detailForm.id);
                if (target) { Object.assign(target, detailForm); saveToLocal(); selectedSpot.value = target; }
                isEditingDetail.value = false;
            };
            const deleteSpot = () => { if (confirm('確定要刪除？')) { spots.value = spots.value.filter(s => s.id !== detailForm.id); saveToLocal(); closeDetailModal(); } };
            const handleFileUpload = async (e) => {
                const file = e.target.files[0]; if (!file) return; isProcessingImage.value = true;
                try { const data = await compressImage(file); detailForm.images.push(data); } 
                catch (e) { alert("失敗"); } finally { isProcessingImage.value = false; e.target.value = ''; }
            };

            const getColorCode = (n) => ({ pink: '#EC4899', blue: '#3B82F6', green: '#10B981', yellow: '#F59E0B', purple: '#8B5CF6' }[n]);
            const getCategoryIcon = (c) => ({ spot: 'fa-camera', food: 'fa-utensils', shopping: 'fa-shopping-bag' }[c]);
            const getCategoryName = (c) => ({ spot: '景點', food: '餐廳', shopping: '購物' }[c]);
            const getCategoryColorClass = (c) => ({ spot: 'bg-pink-50 border-pink-200 text-pink-500', food: 'bg-orange-50 border-orange-200 text-orange-500', shopping: 'bg-blue-50 border-blue-200 text-blue-500' }[c]);

            return { 
                spots, isAddingMode, isProcessingImage, showQuickAddModal, quickForm, showDetailModal, detailForm, isEditingDetail, selectedSpot, currentSpotIndex, fileInput, mapContentRef, isDraggingSpotId,
                toggleAddMode, handleMapClick, handlePinStart, handleContainerMove, handleContainerEnd, handlePinClick,
                cancelQuickAdd, confirmQuickAdd, closeDetailModal, startEditing, cancelEditing, saveDetailChanges, deleteSpot,
                handleFileUpload, getColorCode, getCategoryIcon, getCategoryName, getCategoryColorClass, handleSwipeStart, handleSwipeEnd,
                handleImgError, subwayImgRef
            };
        }
    }).mount('#app');
</script>
</body>
</html>


