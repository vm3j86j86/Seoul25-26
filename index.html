<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>首爾地圖助手 - 手繪可愛版</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <!-- Google Fonts: Zen Maru Gothic -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* 配色方案 */
        :root {
            --c-base: #ffefd7;      /* 背景奶油色 */
            --c-main: #f8d9bd;      /* 主色 (杏桃) */
            --c-mint: #d5e6e0;      /* 點綴 (薄荷) */
            --c-pink: #f6c0b4;      /* 點綴 (粉鮭) */
            --c-text: #5d4037;      /* 深咖啡文字 */
        }

        body {
            font-family: 'Zen Maru Gothic', sans-serif;
            background-color: var(--c-base);
            color: var(--c-text);
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; 
        }

        /* 滾動條樣式 */
        .cute-scrollbar::-webkit-scrollbar { width: 6px; }
        .cute-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .cute-scrollbar::-webkit-scrollbar-thumb { background-color: var(--c-main); border-radius: 10px; }

        /* 動畫設定 */
        @keyframes bounce-in {
            0% { transform: scale(0); opacity: 0; }
            60% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); }
        }
        .marker-enter-active { animation: bounce-in 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        .marker-leave-active { transition: opacity 0.3s ease, transform 0.3s ease; }
        .marker-leave-to { transform: scale(0); opacity: 0; }

        .modal-enter-active, .modal-leave-active { transition: opacity 0.3s ease, transform 0.3s ease; }
        .modal-enter-from, .modal-leave-to { opacity: 0; transform: scale(0.95); }

        .trash-enter-active, .trash-leave-active { transition: transform 0.3s ease; }
        .trash-enter-from, .trash-leave-to { transform: translateY(100%); }

        /* 陰影與互動 */
        .shadow-cute { box-shadow: 2px 2px 0px rgba(160, 120, 100, 0.2); }
        
        /* 拖曳時的樣式修正 */
        .dragging-marker {
            opacity: 0.9;
            z-index: 100 !important;
            pointer-events: none;
            filter: drop-shadow(0 10px 10px rgba(0,0,0,0.2));
            /* 拖曳時稍微上浮 (-140%) 讓手指不會擋住針尖，並放大 */
            transform: translate(-50%, -140%) scale(1.2) !important; 
            
            /* 強制關閉過渡效果，防止殘影 */
            transition: none !important; 
            will-change: left, top; 
        }

        /* SVG 手繪風格設定 */
        .doodle-icon {
            fill: none;
            stroke: currentColor;
            stroke-width: 2.5;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* 拍立得效果 */
        .polaroid {
            background: white;
            padding: 10px 10px 30px 10px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            transform: rotate(-2deg);
            transition: transform 0.3s;
        }
        .polaroid:hover {
            transform: rotate(0deg) scale(1.02);
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="app" class="h-[100dvh] w-screen flex flex-col relative bg-[#ffefd7]">

        <!-- ========================================== -->
        <!-- 上半部：互動標記地圖 (50% 高度) -->
        <!-- ========================================== -->
        <div 
            ref="topMapContainer"
            class="h-1/2 flex-1 w-full relative overflow-hidden bg-white border-b-4 border-white select-none touch-none"
            :class="{ 'cursor-crosshair': isAddingMode }"
            @click="handleMapClick"
            @touchstart.passive="handleTopTouchStart"
            @touchmove.prevent="handleTopTouchMove"
            @touchend="handleTopTouchEnd"
            @mousedown="handleTopMouseDown"
            @mousemove="handleTopMouseMove"
            @mouseup="handleTopMouseUp"
            @mouseleave="handleTopMouseUp"
        >
            <!-- 地圖內容層 -->
            <div 
                class="w-full h-full relative origin-top-left will-change-transform"
                :style="topMapTransformStyle"
            >
                <img 
                    src="map.png" 
                    alt="Seoul District Map" 
                    class="w-full h-full object-contain pointer-events-none select-none"
                    @dragstart.prevent
                >

                <!-- 地圖上的標記 (Markers) -->
                <transition-group name="marker">
                    <div 
                        v-for="marker in markers" 
                        :key="marker.id"
                        class="absolute cursor-pointer group z-20 select-none flex flex-col items-center justify-end w-12 h-12"
                        :class="{ 'dragging-marker': dragData.isDragging && dragData.markerId === marker.id }"
                        :style="{ 
                            left: marker.x + '%', 
                            top: marker.y + '%',
                            transform: 'translate(-50%, -100%)' 
                        }"
                        @mousedown.stop="handleMarkerDown($event, marker)"
                        @touchstart.stop="handleMarkerDown($event, marker)"
                    >
                        <!-- 
                            Hit Area: w-12 h-12 (48px) - 擴大點擊範圍
                            Visual Icon: w-8 h-8 (32px) - 保持視覺小巧
                            mb-1: 讓針尖稍微上提，準確對齊 Hit Area 的底線 (錨點)
                        -->
                        <div 
                            class="w-8 h-8 rounded-full shadow-cute border-2 border-white flex items-center justify-center transition-transform relative mb-1 bg-white"
                            :class="getIconStyle(marker.type).bg"
                        >
                            <doodle-icon :type="marker.type" class="w-4 h-4" :class="getIconStyle(marker.type).text"></doodle-icon>
                            
                            <!-- 底部小箭頭 (針尖) -->
                            <div class="absolute -bottom-1 w-2.5 h-2.5 bg-inherit rotate-45 border-r-2 border-b-2 border-white/20"></div>
                        </div>
                        
                        <!-- 已移除文字標籤 -->
                    </div>
                </transition-group>
            </div>

            <!-- UI 層 (Fixed Overlays) -->
            <div class="absolute top-4 left-4 z-30">
                <button 
                    @click.stop="toggleAddMode" 
                    class="w-12 h-12 rounded-full shadow-cute border-2 border-white flex items-center justify-center transition-all"
                    :class="isAddingMode ? 'bg-[#f6c0b4] text-white rotate-45' : 'bg-[#f8d9bd] text-[#5d4037]'"
                >
                    <svg class="doodle-icon w-6 h-6" viewBox="0 0 24 24">
                        <path d="M12 5v14M5 12h14" />
                    </svg>
                </button>
            </div>

            <div class="absolute top-4 right-4 z-30">
                <button 
                    @click.stop="resetTopMapZoom" 
                    class="w-10 h-10 rounded-full bg-white/90 shadow-cute border-2 border-white flex items-center justify-center text-[#5d4037] active:scale-95 transition-transform"
                >
                    <svg class="doodle-icon w-5 h-5" viewBox="0 0 24 24">
                        <path d="M8 3v3a2 2 0 01-2 2H3m18 0h-3a2 2 0 01-2-2V3m0 18v-3a2 2 0 012-2h3M3 16h3a2 2 0 012 2v3" />
                    </svg>
                </button>
            </div>

            <!-- 拖曳刪除區 -->
            <transition name="trash">
                <div 
                    v-if="dragData.isDragging" 
                    ref="trashZone"
                    class="absolute bottom-0 left-0 w-full h-24 bg-red-100/90 flex flex-col items-center justify-center z-50 border-t-2 border-red-300 transition-colors"
                    :class="{ 'bg-red-200': dragData.isInTrashZone }"
                >
                    <svg class="doodle-icon w-8 h-8 mb-1" :class="dragData.isInTrashZone ? 'text-red-600 scale-125 transition-transform' : 'text-red-400'" viewBox="0 0 24 24">
                        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2M10 11v6M14 11v6" />
                    </svg>
                    <span class="text-sm font-bold text-red-500">{{ dragData.isInTrashZone ? '放開刪除' : '拖曳到此刪除' }}</span>
                </div>
            </transition>

            <!-- 類型選擇選單 -->
            <div 
                v-if="showTypeSelector"
                class="absolute bg-white rounded-2xl shadow-cute p-2 flex gap-2 z-40"
                :style="typeSelectorStyle"
            >
                <button @click.stop="confirmAddMarker('attraction')" class="w-10 h-10 rounded-xl bg-[#d5e6e0] text-[#2c5f4c] hover:bg-[#bde0d3] flex items-center justify-center">
                    <doodle-icon type="attraction" class="w-5 h-5"></doodle-icon>
                </button>
                <button @click.stop="confirmAddMarker('food')" class="w-10 h-10 rounded-xl bg-[#f8d9bd] text-[#8c4b22] hover:bg-[#ffd1a3] flex items-center justify-center">
                    <doodle-icon type="food" class="w-5 h-5"></doodle-icon>
                </button>
                <button @click.stop="confirmAddMarker('shopping')" class="w-10 h-10 rounded-xl bg-[#f6c0b4] text-[#8a3c3c] hover:bg-[#ffb3a1] flex items-center justify-center">
                    <doodle-icon type="shopping" class="w-5 h-5"></doodle-icon>
                </button>
                <div class="absolute bottom-0 left-1/2 -translate-x-1/2 translate-y-1/2 w-3 h-3 bg-white rotate-45"></div>
            </div>
        </div>

        <!-- ========================================== -->
        <!-- 下半部：可縮放地鐵圖 (50% 高度) -->
        <!-- ========================================== -->
        <div class="h-1/2 flex-1 w-full relative bg-[#ffefd7] overflow-hidden touch-none border-t border-[#f8d9bd]">
            <div 
                ref="imageContainer"
                class="w-full h-full flex items-center justify-center cursor-move"
                @mousedown="startDrag"
                @mousemove="onDrag"
                @mouseup="stopDrag"
                @mouseleave="stopDrag"
                @touchstart.prevent="startTouch"
                @touchmove.prevent="onTouch"
                @touchend.prevent="stopTouch"
                @wheel.prevent="onWheel"
            >
                <div :style="imageStyle" class="origin-center will-change-transform">
                    <img 
                        src="image.png" 
                        alt="Seoul Subway Map" 
                        class="max-w-none shadow-lg pointer-events-none select-none rounded-lg"
                        style="width: 1000px; display: block;" 
                        @dragstart.prevent
                    >
                </div>
            </div>
            <button @click="resetImageZoom" class="absolute bottom-4 right-4 bg-white/90 p-3 rounded-full shadow-cute text-[#5d4037] hover:scale-110 transition z-10 backdrop-blur-sm border border-[#f8d9bd]">
                <svg class="doodle-icon w-5 h-5" viewBox="0 0 24 24">
                    <path d="M8 3v3a2 2 0 01-2 2H3m18 0h-3a2 2 0 01-2-2V3m0 18v-3a2 2 0 012-2h3M3 16h3a2 2 0 012 2v3" />
                </svg>
            </button>
        </div>

        <!-- ========================================== -->
        <!-- 彈出視窗 (Modal) -->
        <!-- ========================================== -->
        <transition name="modal">
            <div v-if="activeMarker" class="fixed inset-0 z-50 flex items-end sm:items-center justify-center bg-[#5d4037]/20 backdrop-blur-[2px] p-0 sm:p-4" @click.self="closeModal">
                
                <div class="bg-[#ffefd7] w-full h-[85vh] sm:h-auto sm:max-h-[80vh] sm:max-w-md sm:rounded-3xl rounded-t-3xl flex flex-col shadow-2xl overflow-hidden transition-all duration-300 border-t-4 border-[#f8d9bd]">
                    
                    <!-- 視窗標題列 -->
                    <div class="flex items-center justify-between p-4 border-b border-[#f8d9bd] bg-[#fffbf2]">
                        <button v-if="activeTopic" @click="backToTopics" class="text-[#8c4b22] px-2 font-bold active:scale-95 flex items-center">
                            <svg class="doodle-icon w-5 h-5 mr-1" viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"/></svg> 
                            返回
                        </button>
                        <h3 class="font-bold text-lg text-[#5d4037] flex-1 text-center truncate px-2">
                            {{ activeTopic ? (isEditing ? '編輯筆記 ✏️' : activeTopic.title) : '選擇主題' }}
                        </h3>
                        
                        <!-- 編輯切換按鈕 -->
                        <button v-if="activeTopic && !isEditing" @click="isEditing = true" class="text-[#8c4b22] px-2 text-sm font-bold bg-[#f8d9bd]/30 rounded-lg py-1 hover:bg-[#f8d9bd]/50">
                            編輯
                        </button>
                        <button v-else @click="closeModal" class="text-[#8c4b22] px-2 active:scale-95">
                            <svg class="doodle-icon w-6 h-6" viewBox="0 0 24 24"><path d="M18 6L6 18M6 6l12 12"/></svg>
                        </button>
                    </div>

                    <!-- 視窗內容區 -->
                    <div class="flex-1 overflow-y-auto p-5 bg-[#ffefd7] cute-scrollbar">
                        
                        <!-- LEVEL 1: 主題列表 -->
                        <div v-if="!activeTopic">
                            <div class="text-center mb-6 py-4 bg-white rounded-2xl border border-[#f8d9bd] shadow-sm">
                                <div class="inline-flex items-center justify-center w-16 h-16 rounded-full mb-2 text-3xl shadow-sm border-2 border-white" :class="getIconStyle(activeMarker.type).bg + ' ' + getIconStyle(activeMarker.type).text">
                                    <doodle-icon :type="activeMarker.type" class="w-8 h-8"></doodle-icon>
                                </div>
                                <p class="text-[#8c4b22] text-sm font-medium mt-2">包含 {{ activeMarker.topics.length }} 個筆記</p>
                            </div>

                            <div class="space-y-3">
                                <div 
                                    v-for="topic in activeMarker.topics" 
                                    :key="topic.id"
                                    @click="selectTopic(topic)"
                                    class="flex items-center p-3 bg-white border-2 border-[#f8d9bd] rounded-2xl active:bg-[#fffbf2] transition cursor-pointer group"
                                >
                                    <div class="w-14 h-14 rounded-xl bg-[#f0f0f0] mr-4 overflow-hidden flex-shrink-0 border border-[#e5e7eb] flex items-center justify-center">
                                        <img v-if="topic.image" :src="topic.image" class="w-full h-full object-cover">
                                        <div v-else class="text-[#d1d5db]">
                                            <svg class="doodle-icon w-6 h-6" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                                        </div>
                                    </div>
                                    <div class="flex-1">
                                        <h4 class="font-bold text-[#5d4037] text-lg">{{ topic.title }}</h4>
                                        <p class="text-xs text-[#8c4b22]/70 truncate">{{ topic.info || '還沒有筆記...' }}</p>
                                    </div>
                                    <svg class="doodle-icon w-5 h-5 text-[#f8d9bd]" viewBox="0 0 24 24"><path d="M9 18l6-6-6-6"/></svg>
                                </div>

                                <button 
                                    @click="addNewTopic"
                                    class="w-full py-4 border-2 border-dashed border-[#f8d9bd] rounded-2xl text-[#8c4b22] hover:bg-[#fffbf2] transition flex items-center justify-center gap-2 font-bold mt-4"
                                >
                                    <svg class="doodle-icon w-5 h-5" viewBox="0 0 24 24"><path d="M12 5v14M5 12h14"/></svg> 
                                    新增主題
                                </button>
                                
                                <p class="text-center text-xs text-[#b49889] mt-6">
                                    長按地圖上的圖標可以移動或刪除喔！
                                </p>
                            </div>
                        </div>

                        <!-- LEVEL 2: 詳細資訊 (瀏覽模式 / 編輯模式) -->
                        <div v-else class="space-y-5">
                            <!-- A. 瀏覽模式 (View Mode) -->
                            <div v-if="!isEditing" class="animate-fade-in space-y-6">
                                <!-- 拍立得照片區 -->
                                <div class="flex justify-center my-4" v-if="activeTopic.image">
                                    <div class="polaroid w-4/5 max-w-[280px]">
                                        <div class="aspect-square bg-gray-100 overflow-hidden mb-2">
                                            <img :src="activeTopic.image" class="w-full h-full object-cover">
                                        </div>
                                        <div class="text-center font-handwriting text-gray-500 text-sm">Memory</div>
                                    </div>
                                </div>
                                <div v-else class="text-center py-8 bg-white/50 rounded-2xl border border-dashed border-[#f8d9bd] text-[#b49889]">
                                    <svg class="doodle-icon w-12 h-12 mx-auto mb-2 opacity-50" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>
                                    <p class="text-sm">還沒有照片</p>
                                </div>

                                <!-- 快捷按鈕區 -->
                                <div class="grid grid-cols-3 gap-3">
                                    <a :href="activeTopic.reserveUrl || '#'" target="_blank" class="flex flex-col items-center justify-center p-3 rounded-2xl bg-[#fffbf2] border-2 border-[#f8d9bd] text-[#8c4b22] transition active:scale-95" :class="!activeTopic.reserveUrl && 'opacity-50 grayscale pointer-events-none'">
                                        <svg class="doodle-icon w-6 h-6 mb-1" viewBox="0 0 24 24"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                                        <span class="text-xs font-bold">預約</span>
                                    </a>
                                    <a :href="activeTopic.mapUrl || '#'" target="_blank" class="flex flex-col items-center justify-center p-3 rounded-2xl bg-[#d5e6e0] border-2 border-[#bde0d3] text-[#2c5f4c] transition active:scale-95" :class="!activeTopic.mapUrl && 'opacity-50 grayscale pointer-events-none'">
                                        <svg class="doodle-icon w-6 h-6 mb-1" viewBox="0 0 24 24"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
                                        <span class="text-xs font-bold">地圖</span>
                                    </a>
                                    <a :href="activeTopic.url || '#'" target="_blank" class="flex flex-col items-center justify-center p-3 rounded-2xl bg-[#f6c0b4] border-2 border-[#ffb3a1] text-[#8a3c3c] transition active:scale-95" :class="!activeTopic.url && 'opacity-50 grayscale pointer-events-none'">
                                        <svg class="doodle-icon w-6 h-6 mb-1" viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
                                        <span class="text-xs font-bold">官網</span>
                                    </a>
                                </div>

                                <!-- 資訊區 -->
                                <div class="bg-white rounded-2xl p-4 border border-[#f8d9bd] shadow-sm space-y-3">
                                    <div class="flex items-start">
                                        <svg class="doodle-icon w-5 h-5 text-[#f8d9bd] mt-0.5 mr-2 shrink-0" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                                        <div>
                                            <p class="text-xs text-[#b49889] font-bold">營業時間</p>
                                            <p class="text-sm text-[#5d4037]">{{ activeTopic.hours || '暫無資訊' }}</p>
                                        </div>
                                    </div>
                                    <hr class="border-dashed border-[#f8d9bd]">
                                    <div class="flex items-start">
                                        <svg class="doodle-icon w-5 h-5 text-[#f8d9bd] mt-0.5 mr-2 shrink-0" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                                        <div>
                                            <p class="text-xs text-[#b49889] font-bold">重要筆記</p>
                                            <p class="text-sm text-[#5d4037] whitespace-pre-wrap">{{ activeTopic.info || '寫點什麼吧...' }}</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- B. 編輯模式 (Edit Mode) -->
                            <div v-else class="animate-fade-in space-y-5">
                                <!-- 圖片上傳區 -->
                                <div class="relative group bg-white p-2 pb-8 rounded-sm shadow-md border border-gray-100 rotate-1 transform transition hover:rotate-0">
                                    <div class="w-full h-48 bg-[#f5f5f5] overflow-hidden flex items-center justify-center relative">
                                        <img v-if="activeTopic.image" :src="activeTopic.image" class="w-full h-full object-cover">
                                        <div v-else class="text-[#9ca3af] flex flex-col items-center">
                                            <svg class="doodle-icon w-8 h-8 mb-2 text-[#f8d9bd]" viewBox="0 0 24 24"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>
                                            <span class="text-sm font-medium">新增照片</span>
                                        </div>
                                        <input type="file" accept="image/*" @change="handleImageUpload" class="absolute inset-0 opacity-0 cursor-pointer z-10">
                                    </div>
                                    <div class="absolute bottom-2 right-4 text-[#9ca3af] text-xs font-handwriting">My Memory</div>
                                </div>

                                <div class="space-y-4">
                                    <div>
                                        <label class="block text-sm font-bold text-[#8c4b22] mb-1 pl-1">主題名稱</label>
                                        <input v-model="activeTopic.title" type="text" class="w-full p-3 bg-white rounded-xl border-2 border-[#f8d9bd] focus:border-[#f6c0b4] outline-none text-[#5d4037]" placeholder="例如：弘大可愛咖啡廳">
                                    </div>

                                    <div class="grid grid-cols-2 gap-3">
                                        <div>
                                            <label class="block text-sm font-bold text-[#8c4b22] mb-1 pl-1">營業時間</label>
                                            <input v-model="activeTopic.hours" type="text" class="w-full p-3 bg-white rounded-xl border-2 border-[#f8d9bd] text-sm outline-none" placeholder="10:00 - 22:00">
                                        </div>
                                        <div>
                                            <label class="block text-sm font-bold text-[#8c4b22] mb-1 pl-1">預約連結</label>
                                            <input v-model="activeTopic.reserveUrl" type="text" class="w-full p-3 bg-white rounded-xl border-2 border-[#f8d9bd] text-sm outline-none" placeholder="CatchTable...">
                                        </div>
                                    </div>

                                    <div>
                                        <label class="block text-sm font-bold text-[#8c4b22] mb-1 pl-1">地圖連結</label>
                                        <div class="flex gap-2">
                                            <input v-model="activeTopic.mapUrl" type="text" class="flex-1 p-3 bg-white rounded-xl border-2 border-[#f8d9bd] text-sm outline-none" placeholder="貼上地圖分享連結...">
                                        </div>
                                    </div>

                                    <div>
                                        <label class="block text-sm font-bold text-[#8c4b22] mb-1 pl-1">網站 / IG</label>
                                        <div class="flex gap-2">
                                            <input v-model="activeTopic.url" type="text" class="flex-1 p-3 bg-white rounded-xl border-2 border-[#f8d9bd] text-sm outline-none" placeholder="https://...">
                                        </div>
                                    </div>

                                    <div>
                                        <label class="block text-sm font-bold text-[#8c4b22] mb-1 pl-1">重要筆記</label>
                                        <textarea v-model="activeTopic.info" rows="3" class="w-full p-3 bg-white rounded-xl border-2 border-[#f8d9bd] text-sm outline-none resize-none" placeholder="必吃推薦、注意事項..."></textarea>
                                    </div>
                                    
                                    <div class="text-right">
                                        <button @click="deleteTopic" class="text-[#f6c0b4] text-xs hover:text-[#e11d48]">刪除此主題</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 底部按鈕區 -->
                    <div class="p-4 border-t border-[#f8d9bd] bg-[#fffbf2]">
                        <!-- 如果正在編輯，顯示完成按鈕 -->
                        <button 
                            v-if="isEditing"
                            @click="isEditing = false" 
                            class="w-full py-3 rounded-2xl font-bold text-[#5d4037] shadow-cute border-2 border-white transform active:scale-95 transition bg-[#f8d9bd] hover:bg-[#ffdab9]"
                        >
                            完成編輯 ✨
                        </button>
                        <!-- 如果是瀏覽模式，顯示關閉按鈕 -->
                        <button 
                            v-else
                            @click="closeModal" 
                            class="w-full py-3 rounded-2xl font-bold text-[#5d4037] shadow-cute border-2 border-white transform active:scale-95 transition bg-[#d5e6e0] hover:bg-[#c1e0d3]"
                        >
                            關閉
                        </button>
                    </div>

                </div>
            </div>
        </transition>

    </div>

    <script>
        const { createApp, ref, computed, watch, onMounted } = Vue;

        // 手繪圖標組件
        const DoodleIcon = {
            props: ['type'],
            template: `
                <svg v-if="type === 'attraction'" viewBox="0 0 24 24" class="doodle-icon">
                    <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                    <circle cx="12" cy="13" r="4"></circle>
                </svg>
                <svg v-else-if="type === 'food'" viewBox="0 0 24 24" class="doodle-icon">
                    <path d="M3 2v7c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2V2"></path>
                    <path d="M7 2v20"></path>
                    <path d="M21 15V2v0a5 5 0 0 0-5 5v6c0 1.1.9 2 2 2h3Zm0 0v7"></path>
                </svg>
                <svg v-else-if="type === 'shopping'" viewBox="0 0 24 24" class="doodle-icon">
                    <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <path d="M16 10a4 4 0 0 1-8 0"></path>
                </svg>
                <svg v-else viewBox="0 0 24 24" class="doodle-icon">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
            `
        };

        createApp({
            components: {
                DoodleIcon
            },
            setup() {
                // ==========================================
                // 1. 上半部地圖標記與縮放邏輯
                // ==========================================
                const topMapContainer = ref(null);
                const isAddingMode = ref(false);
                const showTypeSelector = ref(false);
                const tempMarkerPos = ref({ x: 0, y: 0 }); // 儲存真實的 % 座標
                const markers = ref([]);
                const trashZone = ref(null);
                
                // 標記拖曳資料
                const dragData = ref({ isDragging: false, markerId: null, startX: 0, startY: 0, isInTrashZone: false });
                let longPressTimer = null;

                // 地圖縮放資料 (上半部)
                const topScale = ref(1);
                const topTranslateX = ref(0);
                const topTranslateY = ref(0);
                const topMapState = ref({
                    isDragging: false,
                    startX: 0, // 雙指中心點 X
                    startY: 0, // 雙指中心點 Y
                    initialDistance: 0,
                    initialScale: 1,
                    initialTranslateX: 0,
                    initialTranslateY: 0,
                    anchorInContentX: 0, // 縮放中心點在地圖內容的 X 座標
                    anchorInContentY: 0  // 縮放中心點在地圖內容的 Y 座標
                });

                // 計算地圖的 Transform Style
                const topMapTransformStyle = computed(() => ({
                    transform: `translate(${topTranslateX.value}px, ${topTranslateY.value}px) scale(${topScale.value})`,
                    transition: topMapState.value.isDragging ? 'none' : 'transform 0.1s ease-out'
                }));

                // 計算類型選擇器的位置
                const typeSelectorStyle = computed(() => {
                    if (!topMapContainer.value) return {};
                    const rect = topMapContainer.value.getBoundingClientRect();
                    const mapW = rect.width;
                    const mapH = rect.height;
                    
                    const x = (tempMarkerPos.value.x / 100) * mapW * topScale.value + topTranslateX.value;
                    const y = (tempMarkerPos.value.y / 100) * mapH * topScale.value + topTranslateY.value;
                    
                    return {
                        left: x + 'px',
                        top: y + 'px',
                        transform: 'translate(-50%, -100%) translateY(-10px)'
                    };
                });

                const resetTopMapZoom = () => {
                    topScale.value = 1;
                    topTranslateX.value = 0;
                    topTranslateY.value = 0;
                };
                
                // --- Top Map Touch Events (2-Finger Pan & Zoom) ---
                const handleTopTouchStart = (e) => {
                    // 僅允許雙指操作 (拖曳 + 縮放)
                    if (e.touches.length === 2) {
                        topMapState.value.isDragging = true;

                        // 1. 計算雙指中心點 (Screen 座標)
                        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                        
                        topMapState.value.startX = centerX;
                        topMapState.value.startY = centerY;

                        // 2. 記錄初始狀態
                        topMapState.value.initialTranslateX = topTranslateX.value;
                        topMapState.value.initialTranslateY = topTranslateY.value;
                        topMapState.value.initialScale = topScale.value;

                        // 3. 計算雙指距離
                        topMapState.value.initialDistance = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );

                        // 4. 計算"縮放錨點"在地圖內容中的相對位置 (Content 座標)
                        // 這是關鍵：我們希望手指下的地圖點，在縮放後依然在手指下
                        // ContentX = (ScreenX - ContainerLeft - TranslateX) / Scale
                        // 這裡簡化為相對於 Container 左上角的偏移計算
                        // 但因為我們是全螢幕操作，直接用 touch clientX 減去 container offset 會更準
                        const rect = topMapContainer.value.getBoundingClientRect();
                        const rawX = centerX - rect.left;
                        const rawY = centerY - rect.top;

                        topMapState.value.anchorInContentX = (rawX - topTranslateX.value) / topScale.value;
                        topMapState.value.anchorInContentY = (rawY - topTranslateY.value) / topScale.value;

                    } else if (e.touches.length === 1) {
                        // 單指不移動地圖，防止誤觸
                        // 如果需要單指拖曳標記，那是透過 stopPropagation 在標記上處理的，不會進到這裡
                        // 所以這裡甚麼都不做
                    }
                };

                const handleTopTouchMove = (e) => {
                    if (e.touches.length === 2 && topMapState.value.isDragging) {
                        // 1. 計算新的中心點
                        const currentCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        const currentCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                        
                        // 2. 計算新的距離與縮放比例
                        const currentDist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        
                        let newScale = topMapState.value.initialScale * (currentDist / topMapState.value.initialDistance);
                        newScale = Math.min(Math.max(1, newScale), 5); // 限制縮放倍率
                        topScale.value = newScale;

                        // 3. 計算新的位移 (Pan + Zoom Compensation)
                        // 我們希望：NewTranslate = CurrentCenter - (AnchorInContent * NewScale)
                        // 這樣就能保證 AnchorInContent 這個點，在縮放後依然位於 CurrentCenter 這個螢幕位置
                        
                        const rect = topMapContainer.value.getBoundingClientRect();
                        const rawCurrentX = currentCenterX - rect.left;
                        const rawCurrentY = currentCenterY - rect.top;

                        topTranslateX.value = rawCurrentX - (topMapState.value.anchorInContentX * newScale);
                        topTranslateY.value = rawCurrentY - (topMapState.value.anchorInContentY * newScale);

                        // 4. 邊界檢查 (如果縮回 1 倍，強制置中歸零，避免飄移)
                        if (newScale <= 1.05) {
                            topTranslateX.value = 0;
                            topTranslateY.value = 0;
                        }
                    } 
                    
                    // 標記拖曳事件 (如果正在拖曳標記，繼續處理)
                    if (dragData.value.isDragging && e.touches.length === 1) {
                         handleMapDragMove(e);
                    }
                };

                const handleTopTouchEnd = (e) => {
                    topMapState.value.isDragging = false;
                    
                    if (topScale.value <= 1.05) {
                        topScale.value = 1;
                        topTranslateX.value = 0;
                        topTranslateY.value = 0;
                    }

                    if (dragData.value.isDragging) {
                        handleMapDragEnd(e);
                    }
                };

                // Mouse events (for desktop debugging - keeping simple pan)
                const handleTopMouseDown = (e) => {
                    if (dragData.value.markerId || isAddingMode.value) return;
                    topMapState.value.isDragging = true;
                    topMapState.value.startX = e.clientX;
                    topMapState.value.startY = e.clientY;
                    topMapState.value.initialX = topTranslateX.value;
                    topMapState.value.initialY = topTranslateY.value;
                };
                const handleTopMouseMove = (e) => {
                    if (topMapState.value.isDragging && !dragData.value.isDragging) {
                        const dx = e.clientX - topMapState.value.startX;
                        const dy = e.clientY - topMapState.value.startY;
                        if (topScale.value > 1) {
                            topTranslateX.value = topMapState.value.initialX + dx;
                            topTranslateY.value = topMapState.value.initialY + dy;
                        }
                    }
                    if (dragData.value.isDragging) handleMapDragMove(e);
                };
                const handleTopMouseUp = (e) => {
                    topMapState.value.isDragging = false;
                    if (topScale.value <= 1) { topTranslateX.value = 0; topTranslateY.value = 0; }
                    if (dragData.value.isDragging) handleMapDragEnd(e);
                };


                // --- 標記與其他邏輯 ---
                const activeMarker = ref(null);
                const activeTopic = ref(null);
                const isEditing = ref(false);

                onMounted(() => {
                    const saved = localStorage.getItem('seoul-map-markers-v3'); 
                    if (saved) {
                        try { markers.value = JSON.parse(saved); } catch (e) { console.error(e); }
                    }
                });

                watch(markers, (newVal) => {
                    localStorage.setItem('seoul-map-markers-v3', JSON.stringify(newVal));
                }, { deep: true });

                const toggleAddMode = () => {
                    isAddingMode.value = !isAddingMode.value;
                    showTypeSelector.value = false;
                };

                // 計算座標的核心函數
                const getMapPercentFromEvent = (clientX, clientY) => {
                    const rect = topMapContainer.value.getBoundingClientRect();
                    
                    // 1. 取得相對於 Container 左上角的像素座標
                    const rawX = clientX - rect.left;
                    const rawY = clientY - rect.top;
                    
                    // 2. 扣除目前的 Pan (Translate) 位移，並除以 Scale 得到原始未縮放的座標
                    const contentX = (rawX - topTranslateX.value) / topScale.value;
                    const contentY = (rawY - topTranslateY.value) / topScale.value;
                    
                    // 3. 轉為百分比
                    let x = (contentX / rect.width) * 100;
                    let y = (contentY / rect.height) * 100;
                    
                    return { x, y };
                };

                const handleMapClick = (e) => {
                    if (dragData.value.isDragging || topMapState.value.isDragging) return;
                    if (!isAddingMode.value) return;
                    
                    const { x, y } = getMapPercentFromEvent(e.clientX, e.clientY);
                    
                    tempMarkerPos.value = { x, y };
                    showTypeSelector.value = true;
                };

                const handleMarkerDown = (e, marker) => {
                    if (isAddingMode.value) return; 

                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    if (longPressTimer) clearTimeout(longPressTimer);
                    dragData.value.startX = clientX;
                    dragData.value.startY = clientY;
                    dragData.value.markerId = marker.id; 

                    longPressTimer = setTimeout(() => {
                        dragData.value.isDragging = true;
                        longPressTimer = null;
                    }, 300);
                };

                const handleMapDragMove = (e) => {
                    if (!dragData.value.isDragging && longPressTimer) {
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        const moveDist = Math.hypot(clientX - dragData.value.startX, clientY - dragData.value.startY);
                        
                        if (moveDist > 10) { 
                            clearTimeout(longPressTimer); 
                            longPressTimer = null; 
                        }
                        return;
                    }

                    if (dragData.value.isDragging) {
                        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                        
                        const { x, y } = getMapPercentFromEvent(clientX, clientY);
                        
                        const newX = Math.max(0, Math.min(100, x));
                        const newY = Math.max(0, Math.min(100, y));

                        const targetMarker = markers.value.find(m => m.id === dragData.value.markerId);
                        if (targetMarker) { targetMarker.x = newX; targetMarker.y = newY; }

                        const trashRect = topMapContainer.value.querySelector('.absolute.bottom-0')?.getBoundingClientRect();
                        if (trashRect) { dragData.value.isInTrashZone = clientY > trashRect.top; }
                    }
                };

                const handleMapDragEnd = (e) => {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                        
                        if (!isAddingMode.value && dragData.value.markerId) {
                            const marker = markers.value.find(m => m.id === dragData.value.markerId);
                            if (marker) openMarkerModal(marker);
                        }
                    }

                    if (dragData.value.isDragging) {
                        if (dragData.value.isInTrashZone) {
                            markers.value = markers.value.filter(m => m.id !== dragData.value.markerId);
                        }
                        dragData.value.isDragging = false;
                        dragData.value.markerId = null;
                        dragData.value.isInTrashZone = false;
                    }
                };
                
                const openMarkerModal = (marker) => {
                    activeMarker.value = marker;
                    activeTopic.value = null;
                };

                const confirmAddMarker = (type) => {
                    const newMarker = {
                        id: Date.now(),
                        x: tempMarkerPos.value.x,
                        y: tempMarkerPos.value.y,
                        type: type,
                        topics: [{ id: Date.now() + 1, title: '新地點', image: null, url: '', mapUrl: '', hours: '', reserveUrl: '', info: '' }]
                    };

                    markers.value.push(newMarker);
                    showTypeSelector.value = false;
                    isAddingMode.value = false;
                    setTimeout(() => openMarkerModal(newMarker), 100);
                };

                const getIconStyle = (type) => {
                    switch (type) {
                        case 'attraction': return { bg: 'bg-[#d5e6e0]', text: 'text-[#2c5f4c]' };
                        case 'food': return { bg: 'bg-[#f8d9bd]', text: 'text-[#8c4b22]' };
                        case 'shopping': return { bg: 'bg-[#f6c0b4]', text: 'text-[#8a3c3c]' };
                        default: return { bg: 'bg-[#f0f0f0]', text: 'text-[#666]' };
                    }
                };

                // ==========================================
                // 2. 模態框邏輯
                // ==========================================
                const selectTopic = (topic) => {
                    activeTopic.value = topic;
                    isEditing.value = false;
                };
                
                const backToTopics = () => activeTopic.value = null;
                const closeModal = () => { activeMarker.value = null; activeTopic.value = null; };

                const addNewTopic = () => {
                    const newTopic = { 
                        id: Date.now(), 
                        title: '新筆記', 
                        image: null, 
                        url: '', 
                        mapUrl: '', 
                        hours: '', 
                        reserveUrl: '', 
                        info: '' 
                    };
                    
                    activeMarker.value.topics.push(newTopic);
                    activeTopic.value = newTopic;
                    isEditing.value = true;
                };

                const handleImageUpload = (event) => {
                    const file = event.target.files[0];
                    if (file && activeTopic.value) {
                        const reader = new FileReader();
                        reader.onload = (e) => { activeTopic.value.image = e.target.result; };
                        reader.readAsDataURL(file);
                    }
                };

                const deleteTopic = () => {
                    if (confirm("確定刪除此主題？")) {
                        const idx = activeMarker.value.topics.indexOf(activeTopic.value);
                        if (idx > -1) {
                            activeMarker.value.topics.splice(idx, 1);
                            activeTopic.value = null;
                        }
                    }
                };

                // ==========================================
                // 3. 下半部縮放地鐵圖邏輯 (保持原樣)
                // ==========================================
                const scale = ref(1);
                const translateX = ref(0);
                const translateY = ref(0);
                const isDragging = ref(false);
                const startX = ref(0);
                const startY = ref(0);
                const initialX = ref(0);
                const initialY = ref(0);
                const initialDistance = ref(0);
                const initialScale = ref(1);

                const imageStyle = computed(() => ({
                    transform: `translate(${translateX.value}px, ${translateY.value}px) scale(${scale.value})`,
                    transition: isDragging.value ? 'none' : 'transform 0.1s ease-out'
                }));

                const resetImageZoom = () => { scale.value = 1; translateX.value = 0; translateY.value = 0; };
                const startDrag = (e) => { isDragging.value = true; startX.value = e.clientX; startY.value = e.clientY; initialX.value = translateX.value; initialY.value = translateY.value; };
                const onDrag = (e) => {
                    if (!isDragging.value) return;
                    e.preventDefault();
                    translateX.value = initialX.value + (e.clientX - startX.value);
                    translateY.value = initialY.value + (e.clientY - startY.value);
                };
                const stopDrag = () => { isDragging.value = false; };

                const startTouch = (e) => {
                    if (e.touches.length === 1) {
                        isDragging.value = true;
                        startX.value = e.touches[0].clientX; startY.value = e.touches[0].clientY;
                        initialX.value = translateX.value; initialY.value = translateY.value;
                    } else if (e.touches.length === 2) {
                        isDragging.value = false;
                        initialDistance.value = getDistance(e.touches); initialScale.value = scale.value;
                    }
                };

                const onTouch = (e) => {
                    if (e.touches.length === 1 && isDragging.value) {
                        translateX.value = initialX.value + (e.touches[0].clientX - startX.value);
                        translateY.value = initialY.value + (e.touches[0].clientY - startY.value);
                    } else if (e.touches.length === 2) {
                        const distance = getDistance(e.touches);
                        if (initialDistance.value === 0) return;
                        let newScale = initialScale.value * (distance / initialDistance.value);
                        newScale = Math.min(Math.max(0.5, newScale), 5); 
                        scale.value = newScale;
                    }
                };

                const stopTouch = () => { isDragging.value = false; initialDistance.value = 0; };
                const onWheel = (e) => {
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    let newScale = scale.value * delta;
                    newScale = Math.min(Math.max(0.5, newScale), 5);
                    scale.value = newScale;
                };

                const getDistance = (touches) => {
                    return Math.sqrt(Math.pow(touches[0].clientX - touches[1].clientX, 2) + Math.pow(touches[0].clientY - touches[1].clientY, 2));
                };

                return {
                    // Top Map Logic
                    topMapContainer, isAddingMode, toggleAddMode, handleMapClick,
                    markers, showTypeSelector, tempMarkerPos, confirmAddMarker, getIconStyle,
                    dragData, handleMarkerDown, handleMapDragMove, handleMapDragEnd, trashZone,
                    activeMarker, activeTopic, openMarkerModal, selectTopic, backToTopics, closeModal,
                    addNewTopic, handleImageUpload, deleteTopic,
                    // Top Map Zoom
                    topMapTransformStyle, handleTopTouchStart, handleTopTouchMove, handleTopTouchEnd,
                    handleTopMouseDown, handleTopMouseMove, handleTopMouseUp, resetTopMapZoom, typeSelectorStyle,
                    
                    // Bottom Map Logic
                    imageStyle, resetImageZoom,
                    startDrag, onDrag, stopDrag, startTouch, onTouch, stopTouch, onWheel,
                    isEditing
                };
            }
        }).mount('#app');
    </script>
</body>
</html>


